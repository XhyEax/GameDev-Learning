# Week-1
查阅相关资料，写实验程序

理解下面概念的区别，写在注释里

## 1. 变量的区别
声明(Declaration)和定义(Definition)：声明仅告诉编译器变量的类型，定义时才分配内存空间
静态变量和非静态变量：静态变量使用`static`修饰，程序执行过程中只初始化一次，不初始化则为0，存储在静态区。
全局变量和局部变量：全局变量声明在所有函数外部。局部变量声明在函数体中，只能在函数内使用
成员变量：C++中在类内部声明的变量
### 非静态全局变量
在别的文件中使用`extern`修饰变量，提示编译器在其他模块中寻找其定义。
生命周期：整个程序的执行时间
作用域：程序的所有语句
### 静态全局变量
该全局变量只能在本文件内使用
生命周期：整个程序的执行时间
作用域：**本文件**的所有语句
### 非静态局部变量
生命周期：函数某一次执行的时间
作用域：函数的所有语句
### 静态局部变量
生命周期：整个程序的执行时间
作用域：函数的所有语句
### 非静态成员变量
生命周期：对象的创建到结束
作用域：类对象
### 静态成员变量
生命周期：整个程序的执行时间
作用域：类本身

## 2. 通过一个函数改变函数外变量的值
### 全局变量
### 指针
地址，可以为空
### 引用
别名，一定不为空
实际上是常指针
## 3. 深拷贝和浅拷贝的区别
### 浅拷贝
在对象拷贝过程中，如果没有自定义拷贝构造函数，系统会提供一个缺省的拷贝构造函数。

对于基本类型的成员变量，按字节复制；对于类类型成员变量，调用其相应类型的拷贝构造函数；对于指针型成员变量只复制指针本身，而不复制指针所指向的目标。

#### 浅拷贝存在的问题
更改指针指向的值，其他实例中指针指向的数据也会一同改变，因为实际使用的是同一个地址。

如果在析构函数中释放内存，浅拷贝会导致同一个地址被释放两次，引发异常。

函数调用中，生成参数和返回值时，也会隐式调用拷贝构造函数。
### 深拷贝
深拷贝需要自定义类的拷贝构造函数，在其中完成指针型成员变量的处理，如申请空间，并复制指针所指向值。

## 4. 堆内存和栈内存的区别
### 堆内存
手动申请与释放
### 栈内存
由编译器自动分配与释放
向内存地址减小的方向增长，由高向低

## 5. 生命周期和作用域
### 生命周期 (Life Cycle)
某个变量能够使用的时间范围
### 作用域 (Scope)
可以使用这个变量的所有语句的总和

## 参考
[Detail C++ scope and life cycle](https://ofstack.com/C++/29230/detail-c++-scope-and-life-cycle.html)
[Scope & Lifetime](https://www.csee.umbc.edu/~chang/cs202.f15/Lectures/modules/m05-scope/slides.php?print)
[堆和栈的理解和区别，C语言堆和栈完全攻略](http://c.biancheng.net/c/stack/)
[C/C++中extern关键字详解](https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html)
[C++全局变量的声明和定义](https://www.cnblogs.com/Dageking/p/3185230.html)
[（三）生命周期与作用域](https://blog.csdn.net/hang_1994/article/details/53644007)
[C 生命周期和作用域](https://blog.csdn.net/guaiderzhu1314/article/details/104103483)
[浅谈C++深拷贝与浅拷贝的区别](https://blog.csdn.net/xxh20188345/article/details/119001145)
[C++细节 深拷贝和浅拷贝(位拷贝）详解](https://blog.csdn.net/weixin_41143631/article/details/81486817)
